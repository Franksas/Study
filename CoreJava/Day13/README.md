# 第十三天笔记
##
###
- 被final修饰的文档String、System,不能被继承
- final可以修饰类、属性（局部变量）、方法；
- 修饰类，类不能被继承（不能有子类）；
- 修饰属性，属性值不能被更改；
- 修饰方法，方法不能被重写；
- 请列举API中常用的哪几个类是被final修饰的：System、String等
- 被final修饰的属性的方法可以被显式赋值，也可以是构造方法赋值；但不可以同时显式赋值和构造方法赋值
- final修饰复合类型属性，地址不能变，但内容可变
- final不可以修饰构造方法；
- static不可以修饰外部类、构造方法、局部变量；可以修饰
- static int age = 20; // 静态变量，类变量
       int grade = 33; // 非静态变量，实例变量
static void abd() {} // 静态方法，类方法
- 在静态方法中不能直接使用非静态变量和方法；可以新建对象来使用；
- 静态变量与类相关，被所有对象共享；
- 在静态方法里不能使用非静态变量和方法
- 执行顺序：静态的、非静态的、构造方法
- 继承的执行顺序：父类的静态，子类的静态、父类的非静态，构造方法、子类的非静态，构造方法
#### 单子设计模式（单例设计模式）
- 一个类只能创建一个对象
1.构造方法私有2.提供私有、静态属性且是当前类 类型
3.提供公共的、静态方法，返回当前类对象
#### 抽象类
- abstract可以修饰类和方法；抽象方法没有方法体；
不能修饰属性；
- 拥有抽象方法的类必须是抽象类；抽象类不一定拥有抽象方法；
- 抽象方法必须被重写；
- 抽象类有构造方法，但是不能用来创建对象；
- 抽象类的目的在于解耦；
- private和abstract在方法前面不能同时出现；
- 构造方法不能被abstract修饰；
- final和abstract不能同时出现；
####接口
- 为什么使用接口
降低耦合
- 接口中的所有方法都是抽象方法
接口中的属性默认被public|final|static修饰
- 接口中的方法默认被public修饰
- 先继承再实现
- 接口也是复合类型之一，可以当属性的类型；同样可以修饰局部变量、作为方法返回值
接口支持多继承
- 接口也是复合类型之一
- 接口和抽象类的区别
1.语法不同
2.抽象类有构造方法，接口没有
3.抽象类中抽象方法是可选的，接口全部是
4.抽象类是被类继承的，接口是被类实现的
